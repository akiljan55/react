var React = require('react');
var Map = require('immutable').Map;

function applyKeysToObject (obj, other) {
  for (var key in other) {
    obj[key] = other[key];
  }
}

function mergeStateAndProps (state, props) {
  var finalProps = {};

  applyKeysToObject(finalProps, state);
  applyKeysToObject(finalProps, props);

  return finalProps;
}

function notEqual (next, prev) {
  if (next === prev) {
    return false;
  }

  if (typeof next !== 'object' || next === null || typeof prev !== 'object' || prev === null) {
    return true;
  }

  if (Object.keys(next).length !== Object.keys(prev).length) {
    return true;
  }

  for (var key in next) {
    if (next[key] !== prev[key]) {
      return true;
    }
  }

  return false;
}

function createConnectedComponent (mapStateToProps, Component, store) {
  if (typeof mapStateToProps !== 'function') {
    throw new Error('Map state to props must be a function.');
  }

  return React.createClass({
    displayName: 'ConnectedComponent',

    shouldComponentUpdate: function (nextProps, nextState) {
      return notEqual(nextProps, this.props) || notEqual(nextState, this.state);
    },

    updateState: function () {
      const state = mapStateToProps(store.getState());

      if (typeof state !== 'object' || state === null) {
        throw new Error('Map state to props function must return an object.');
      }

      this.setState(state);
    },

    componentWillMount: function () {
      this.updateState();
      store.addListener(this.updateState);
    },

    componentWillUnmount: function () {
      store.removeListener(this.updateState);
    },

    render: function () {
      return React.createElement(Component, mergeStateAndProps(this.state, this.props));
    }
  });
}

module.exports = function Store (actions) {
  var store = this;
  var state = Map();
  var listeners = [];
  var actionChain = [];
  var actionInProgress = false;

  store.actions = {};

  function createAction (callback) {
    return function () {
      var dispatchArgs = Array.prototype.slice.call(arguments);

      actionChain.push(function () {
        return callback.apply(store, [state].concat(dispatchArgs));
      });

      while (!actionInProgress && actionChain.length) {
        actionInProgress = true;
        state = actionChain.shift()();

        for (var i = 0; i < listeners.length; i += 1) {
          listeners[i]();
        }

        actionInProgress = false;
      }
    };
  }

  for (var key in actions) {
    store.actions[key] = createAction(actions[key]);
  }

  store.addListener = function (callback) {
    listeners.push(callback);
  };

  store.removeListener = function (callback) {
    var index = listeners.indexOf(callback);

    if (index >= 0) {
      listeners.splice(index, 1);
    }
  };

  store.getState = function () {
    return state;
  };

  store.map = function (mapStateToProps) {
    return {
      to: function (Component) {
        return createConnectedComponent(mapStateToProps, Component, store);
      }
    };
  };
};
